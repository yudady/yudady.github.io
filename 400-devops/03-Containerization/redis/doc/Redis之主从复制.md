## 基础定义

主机数据更新后根据配置和策略，自动同步到备机的master/slaver机制，Master以写为主，Slave以读为主

## 应用场景

- 读写分离
- 容灾恢复

## 如何使用

### 常用命令

- slaveof 主库IP 主库端口
- `info replication` # 查看主从配置信息
- `slaveof no one` # 使当前数据库停止与其他数据库的同步，转成主数据库

### 1. 配从不配主

- 从库配置：slaveof 主库IP 主库端口

- 每次与master断开之后，都需要重新连接，除非配置到redis.conf文件中

### 2. 修改配置文件细节

- 拷贝多个redis.conf文件
- 设置daemonize的值为yes
- 修改pid文件名称
- 指定启动端口
- 修改log文件名
- 修改dump.rdb文件名


### 3. 常用配置策略

#### 策略一：一主二仆

一个Master，两个Slave

主从问题思考：

1 切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的123是否也可以复制

答：

2 从机是否可以写？set可否？

答：

3 主机shutdown后情况如何？从机是上位还是原地待命

答：

4 主机又回来了后，主机新增记录，从机还能否顺利复制？

答：

5 其中一台从机down后情况如何？依照原有它能跟上大部队吗？

答：

#### 策略二：薪火相传

上一个Slave可以是下一个slave的Master，Slave同样可以接收其他
slaves的连接和同步请求，那么该slave作为了链条中下一个的master,
可以有效减轻master的写压力。

中途变更转向:会清除之前的数据，重新建立拷贝最新的

主从问题思考：

1 切入点问题？slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的123是否也可以复制

答：

2 从机是否可以写？set可否？

答：

3 主机shutdown后情况如何？从机是上位还是原地待命

答：

4 主机又回来了后，主机新增记录，从机还能否顺利复制？

答：

5 其中一台从机down后情况如何？依照原有它能跟上大部队吗？

答：

#### 策略三：哨兵模式

反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库

1. 自定义的/myredis目录下新建sentinel.conf文件，名字绝不能错
2. 配置哨兵,填写内容
    1.  sentinel monitor 被监控数据库名字(自己起名字) 127.0.0.1 6379 1
    2. 上面最后一个数字1，表示主机挂掉后salve投票看让谁接替成为主机，得票数多少后成为主机
3. 启动哨兵
    1. redis-sentinel /myredis/sentinel.conf 
    2. 上述目录依照各自的实际情况配置，可能目录不同
4. 如果原来的master挂了，投票重选，重新主从继续开工，可通过`info replication`查看
5. 如果之前挂掉的master重新恢复之后，自动变为salve
6. 一组sentinel能同时监控多个Master



## 复制原理

1. slave启动成功连接到master后会发送一个sync命令

2. Master接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步

3. 全量复制：slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。

4. 增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步

    注意：只要是重新连接master,一次完全同步（全量复制)将被自动执行

## 复制缺点

复制的延时

由于所有的写操作都是先在Master上操作，然后同步更新到Slave上，所以从Master同步到Slave机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave机器数量的增加也会使这个问题更加严重。