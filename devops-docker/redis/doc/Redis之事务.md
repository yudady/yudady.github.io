## 基础定义

简单地说，事务表示一 组动作，要么全部执行，要么全部不执行。

Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和 exec两个命令之间。multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的。

Redis并不支持回滚功能。

## 使用场景

一个队列中，一次性、顺序性、排他性的执行一系列命令

## 如何使用

### 常用命令：

- multi 

- exec

- discard ：停止事务的执行

- watch

- unwatch

### 事务失效

1. 语法错误，会造成整个事务无法执行，如将set写成了sett

2. 运行时错误，会造成部分成功，部分失败。

### watch监控

1. 悲观锁/乐观锁/CAS(Check And Set)

    1. 悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁

    2. 乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，

        乐观锁策略:提交版本必须大于记录当前版本才能执行更新

    3. 行锁（乐观锁）

        对行加锁：并发性好，一致性差

    4. 表锁（悲观锁）

        对整张表加锁：并发性极差，一致性最好

    5. CAS

2. 银行转账示例

    1. 初始化信用卡可用余额和欠额
    2. 无加塞篡改：先监控再开启multi，保证两笔金额变动在同一个事务内
    3. 有加塞篡改：监控了key，如果key被修改了，后面一个事务的执行失效
    4. 一旦执行了exec之前加的监控锁都会被取消掉了

3. Watch指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，比如某个list已被别的客户端push/pop过了，整个事务队列都不会被执行.

4. 通过WATCH命令在事务执行之前监控了**多个**Keys，倘若在WATCH之后有**任何**Key的值发生了变化，
    EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败.

## Redis事务三阶段

1. 开启：以MULTI开始一个事务
2. 入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面
3. 执行：由EXEC命令触发事务

## Redis事务三特点

1. 单独的隔离操作

    事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。

2. 没有隔离级别的概念

    队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在”事务内的查询要看到事务里的更新，在事务外查询不能看到”这个让人万分头痛的问题

3. 不保证原子性

    redis同一个事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚

